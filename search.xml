<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷P1357花园]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%B4%9B%E8%B0%B7P1357%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$. 那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即$1$的个数不超过$k$）。($Floyd$矩阵) 所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。 那么怎么求得$f[i][j]$呢？ 枚举一个长度为$m-1$的状态，在它前面加$0/1$即是$i$，在它后面加$0/1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。 由于是个环，所以实质上有$n+m$个花圃，第$n+1$~$n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;int n,m,k,t,o[39+39],ans;struct node&#123; int a[39+39][39+39]; inline void init()&#123; for (int i=0;i&lt;=t;++i) for (int j=0;j&lt;=t;++j) if (i==j) a[i][i]=1; else a[i][j]=0; &#125; inline void init0()&#123;memset(a,0,sizeof(a));&#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=0;i&lt;=t;++i) for (int k=0;k&lt;=t;++k) for (int j=0;j&lt;=t;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int count(int x)&#123; int res=0; while (x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read(); t=(1&lt;&lt;m)-1; for (int i=0;i&lt;=t&gt;&gt;1;++i)&#123; int num=count(i); if (num&lt;=k)&#123; o[i]=1,o[i&lt;&lt;1]=1; f.a[i][i&lt;&lt;1]=1; &#125; if (num+1&lt;=k)&#123; o[i|(1&lt;&lt;m-1)]=1,o[i&lt;&lt;1|1]=1; f.a[i][i&lt;&lt;1|1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1|1]=1; &#125; &#125; f=f^n; for (int i=0;i&lt;=t;++i) if (o[i]) ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i]; cout&lt;&lt;ans; return 0;&#125;]]></content>
  </entry>
</search>
