<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 CF24D 【Broken robot】]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%A2%98%E8%A7%A3%20CF24D%20%E3%80%90Broken%20robot%E3%80%91%2F</url>
    <content type="text"><![CDATA[设状态$f[i][j]$为从坐标$(i,j)$走到最后一行的期望 此时需要分类讨论,由于$f[n][j]=0(1&lt;=j&lt;=m)$，所以我们倒着枚举行,也可感性理解为从最后一行走到第x行 当$j=1$时，$f[i][1]=\frac{1}{3}f[i][1]+\frac{1}{3}f[i][2]+\frac{1}{3}f[i+1][1]+1$ 当$j=m$时，$f[i][m]=\frac{1}{3}f[i][m]+\frac{1}{3}f[i][m-1]+\frac{1}{3}f[i+1][m]+1$ 当$1&lt;j&lt;m$时，$f[i][j]=\frac{1}{4}f[i][j-1]+\frac{1}{4}f[i][j]+\frac{1}{4}f[i][j+1]+\frac{1}{4}f[i+1][j]+1$ 然后我们发现这个式子是有后效性的，所以要$dp+$高斯消元。 为了更好高斯消元，我们可以压掉第一维，式子中的$f[i+1]$计为数组$last$。(但我实现上还是用了两维) 经过移项化简后得到： 当$j=1$时，$2f[1]-f[2]=last[i] + 3$ 当$j=m$时，$-f[m-1]+2f[m]=last[m]+3$ 当$1&lt;j&lt;m$时，$-f[j-1]+3f[j]-f[j+1]=last[j]+4$ 由于是倒着枚举，所以$last$数组在转移前已经知道了，这就完全是个高斯消元的式子了，用矩阵表示就会变成下面这个样子 $\begin{bmatrix}&amp;2\ &amp;-1\ &amp;0\ &amp;0\ &amp;0\\&amp;-1\ &amp;3\ &amp;-1\ &amp;0\ &amp;0\\&amp;0 &amp;-1\ &amp;3\ &amp;-1\ &amp; 0\\&amp;0\ &amp;0\ &amp;-1\ &amp;3\ &amp;-1\\&amp;0\ &amp;0\ &amp;0\ &amp;-1\ &amp;2\end{bmatrix}$ 用高斯消元显然会T，但是我们发现每行最多只有$3$个非$0$元素,所以我们可以暴力模拟高斯消元求解,最后答案就是f[x][y] 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define mod 1000000007#define ll long longusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;double f[1007][1007],a1[1007],a2[1007],a3[1007],c[1007];//c数组为方程组'='右边的值，a1,a2,a3分别表示一行中三个元素的值，f数组即为转移数组signed main()&#123; int n=read(),m=read(),x=read(),y=read(); if (m==1)&#123; printf("%.10lf",2.0*(n-x)); return 0; &#125; for (int i=n-1;i&gt;=x;--i)&#123; for (int j=1;j&lt;=m;++j)c[j]=f[i+1][j]+4.0; c[1]-=1.0;c[m]-=1.0; a1[1]=0;a2[1]=2.0;a3[1]=-1.0; for (int j=2;j&lt;=m-1;++j)a1[j]=-1,a2[j]=3,a3[j]=-1; a1[m]=-1;a2[m]=2;a3[m]=0; for (int j=2;j&lt;=m;++j)&#123; double z=a1[j]/a2[j-1]; a2[j]-=z*a3[j-1]; c[j]-=c[j-1]*z; &#125; f[i][m]=c[m]/a2[m]; for (int j=m-1;j;--j)f[i][j]=(f[i][j+1]+c[j])/a2[j]; &#125; printf("%.10lf",f[x][y]);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解 P2444 【[POI2000]病毒】]]></title>
    <url>%2F2019%2F04%2F07%2F%E9%A2%98%E8%A7%A3%20P2444%20%E3%80%90%5BPOI2000%5D%E7%97%85%E6%AF%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[很考验对$fail$指针的理解,假设我们构造出了一个无限长的安全代码，再到$AC$自动机上匹配，从原点出发，向下走遇到一个环，然后不停地在这个环上跳转(无法理解就手玩样例)，且这个环上没有危险节点(即病毒单词最后一个字母在$Trie$树上的位置) 注意：这个环不包括$fail$指针,但是包括优化边(即如果节点$i$的某个字符儿子为空，那么这个儿子存为$i$的$fail$指针指向的节点的相同字符儿子)(有点绕,放张样例构成的$trie$图) 黑边是$trie$树上的正常边，蓝边是在处理$AC$自动机时连上的优化边，红边是$fail$指针。灰色节点即危险节点 这里的环只由蓝边和黑边构成的，即不考虑走$fail$指针， 这样，问题就变成了找一个从根节点出发能在不经过危险节点的情况下走到到的环，且环上没有危险节点。 注意：如果某个点的$fail$指针指向的点是有危险节点，那么该节点也是危险节点 接下来$dfs$找环，找到就输出属于基础图论。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define N 1000007using namespace std;struct node&#123; int fail,cnt,ch[2];&#125;f[N&gt;&gt;1];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int ans,cnt,ok[N],vis[N];char s[N];queue&lt;int&gt;q;inline void build(char *s)&#123; int len=strlen(s),now=0; for (int i=0;i&lt;len;++i)&#123; int v=s[i]-'0'; if (!f[now].ch[v])f[now].ch[v]=++cnt; now=f[now].ch[v]; &#125; f[now].cnt=1;&#125;inline void build_fail()&#123; for (int i=0;i&lt;2;++i)if (f[0].ch[i])q.push(f[0].ch[i]); while (!q.empty())&#123; int u=q.front();q.pop(); for (int i=0;i&lt;2;++i) if (f[u].ch[i])&#123; f[f[u].ch[i]].fail=f[f[u].fail].ch[i]; f[f[u].ch[i]].cnt|=f[f[f[u].fail].ch[i]].cnt; q.push(f[u].ch[i]); &#125;else f[u].ch[i]=f[f[u].fail].ch[i]; &#125;&#125;void dfs(int now)&#123; if (ok[now])&#123;puts("TAK");exit(0);&#125; if (vis[now]||f[now].cnt)return; vis[now]=ok[now]=1; if (f[now].ch[0])dfs(f[now].ch[0]); if (f[now].ch[1])dfs(f[now].ch[1]); ok[now]=0;&#125;signed main()&#123; int n=read(); for (int i=1;i&lt;=n;++i)&#123; scanf("%s",s); build(s); &#125; build_fail(); dfs(0); puts("NIE"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解 51nod有限背包计数问题]]></title>
    <url>%2F2019%2F04%2F07%2F51nod%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 很考验对背包的理解 对于$1$~$sqrt(n)$与$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，分别处理，显然$1$~$sqrt(n)$是个多重背包问题，$(sqrt(n)+$$1)$~$n$是个完全背包问题 对于$1$~$sqrt(n)$，我们可以用总方案数减去不合法的方案数(具体见代码注释)，并利用滚存优化空间 对于$(sqrt(n)+$$1)$~$n,$我们可以用NOIP2001数的划分的类似做法，将划分分成两种类型，进行$dp$转移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3fusing namespace std;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;int f[2][393939],g[319][100007],ans;signed main()&#123;// freopen("game.in", "r", stdin); freopen("game.out", "w", stdout); int n=read(),mod=read(); f[0][0]=1;//选0个的方案数为1 int sq=sqrt(n),now=0; for (int i=1;i&lt;=sq;++i)&#123; now^=1;//滚存 for (int j=0;j&lt;=n;++j)&#123; f[now][j]=f[now^1][j];//加上i-1的方案种数 if (j&gt;=i)f[now][j]+=f[now][j-i];//完全背包方案数的递推式 if (f[now][j]&gt;=mod)f[now][j]-=mod; if (j&gt;=i*(i+1))f[now][j]=f[now][j]-f[now^1][j-i*(i+1)]+mod;//减去不符合的方案数，即不在j-i*i到j范围内的方案数 if (f[now][j]&gt;=mod)f[now][j]-=mod; &#125; &#125;//前sqrt(n)个数进行多重背包计算方案 //g[i][j]表示选了i个,而不是选到第i种，和为j的方案数，注意i的含义与f[i][j]中的i的含义不一样 //类似NOIP2001数的划分的做法,所有划分成两种：//1.包含sqrt(n)+1(即最小的数)//2.不包含sqrt(n)+1的//一个dp状态的方案数就是由这两种划分构成的//对于第一种划分，只需要单独加上一份sqrt(n)+1即可，所以划分数等于f[i-1][j-(sqrt(n)+1)];//对于第二种划分，只需要给当前每份都加上1，每份就不可能等于sqrt(n)+1了，因为最小就是sqrt(n)+1,所以划分数就等于f[i][j+i]; g[0][0]=1;//选0个，和为0的方案数为1 if (sq+1&lt;=n)g[1][sq+1]=1;//选1个sqrt(n)+1(最小值) for (int i=1;i&lt;=sq;++i)&#123; for (int j=0;j&lt;=n;++j)&#123; if (j+sq+1&lt;=n)g[i+1][j+sq+1]+=g[i][j];//第一种划分 if (g[i+1][j+sq+1]&gt;=mod)g[i+1][j+sq+1]-=mod; if (j+i&lt;=n)g[i][j+i]+=g[i][j];//第二种划分 if (g[i][j+i]&gt;=mod)g[i][j+i]-=mod; &#125; &#125; for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=sq;++j)&#123; ans+=1ll*f[now][i]*g[j][n-i]%mod;// 最后枚举多少空间给前sqrt(n)个物品(剩下空间给其它物品) if (ans&gt;=mod)ans-=mod; &#125; printf("%d",ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[题解 CF718C 【Sasha and Array】]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%A2%98%E8%A7%A3%20CF718C%20%E3%80%90Sasha%20and%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[快速求$Fibonacci$第$n$项的方法是用矩阵乘法，即原始矩阵*$Fibonacci$矩阵^$(n-2)$,所以我们可以想到将$n$加上$k$相当于给$f[n]$乘上$Fibonacci$矩阵^$k$，所以我们可以想到线段树维护矩阵 对于第一个问题：由于矩阵具有分配律，即$a×b+a×c=a×(b+c)$，所以对于一段区间的矩阵可以相加维护。 对于第二个问题，显然将$[l,r]$的矩阵乘上转移矩阵的$x$次方即可。 用线段树维护即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define mod 1000000007#define getchar() (p1==p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;using namespace std;struct node&#123; int a[3][3]; inline void init()&#123; a[1][1]=a[2][2]=1;a[1][2]=a[2][1]=0; &#125; inline void init0()&#123; a[1][1]=a[2][2]=a[1][2]=a[2][1]=0; &#125; inline void init1()&#123; a[1][1]=a[2][1]=a[1][2]=1;a[2][2]=0; &#125; friend node operator + (node aa,node bb)&#123; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=1;j++)&#123; aa.a[i][j]=(aa.a[i][j]+bb.a[i][j]); if (aa.a[i][j]&gt;mod)aa.a[i][j]-=mod; &#125; return aa; &#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=1;i&lt;=2;++i) for (int k=1;k&lt;=2;++k) for (int j=1;j&lt;=2;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f[100005],p,jz[500005],tag[500005];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;inline bool check(node tag)&#123; return tag.a[1][1]!=1||!tag.a[2][2]!=1||tag.a[1][2]!=0||tag.a[2][1]!=0;&#125;inline void pushup(int k)&#123; jz[k]=jz[ls(k)]+jz[rs(k)];&#125;void build(int k,int l,int r)&#123; tag[k].init(); if (l==r)&#123; jz[k]=f[l]; return; &#125; int mid=l+r&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r); pushup(k);&#125;inline void pushdown(int k)&#123; node sq=tag[k]; jz[ls(k)]=sq*jz[ls(k)]; tag[ls(k)]=tag[ls(k)]*sq; jz[rs(k)]=sq*jz[rs(k)]; tag[rs(k)]=tag[rs(k)]*sq; tag[k].init();&#125;void change(int k,int l,int r,int x,int y,node sq)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; jz[k]=sq*jz[k]; tag[k]=tag[k]*sq; return; &#125; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,sq); if (mid&lt;y) change(rs(k),mid+1,r,x,y,sq); pushup(k);&#125;node query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return jz[k]; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid&amp;&amp;mid&lt;y) return query(ls(k),l,mid,x,y)+query(rs(k),mid+1,r,x,y); else if (x&lt;=mid)return query(ls(k),l,mid,x,y); else return query(rs(k),mid+1,r,x,y);&#125;signed main()&#123; int n=read(),m=read(); p.init1(); node ttt; ttt.a[1][1]=ttt.a[2][1]=1; for (int i=1;i&lt;=n;++i)&#123; int x=read()-2; if (x==-1)f[i].a[1][1]=1,f[i].a[2][1]=0; else f[i]=(p^x)*ttt; &#125; build(1,1,n); while (m--)&#123; int opt=read(),x=read(),y=read(); if (opt==1)&#123; int d=read(); change(1,1,n,x,y,p^d); &#125;else&#123; node ans=query(1,1,n,x,y); write(ans.a[1][1]);puts(""); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1357花园]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%B4%9B%E8%B0%B7P1357%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$. 那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即$1$的个数不超过$k$）。($Floyd$矩阵) 所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。 那么怎么求得$f[i][j]$呢？ 枚举一个长度为$m-1$的状态，在它前面加$0/1$即是$i$，在它后面加$0/1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。 由于是个环，所以实质上有$n+m$个花圃，第$n+1$~$n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;int n,m,k,t,o[39+39],ans;struct node&#123; int a[39+39][39+39]; inline void init()&#123; for (int i=0;i&lt;=t;++i) for (int j=0;j&lt;=t;++j) if (i==j) a[i][i]=1; else a[i][j]=0; &#125; inline void init0()&#123;memset(a,0,sizeof(a));&#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=0;i&lt;=t;++i) for (int k=0;k&lt;=t;++k) for (int j=0;j&lt;=t;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int count(int x)&#123; int res=0; while (x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read(); t=(1&lt;&lt;m)-1; for (int i=0;i&lt;=t&gt;&gt;1;++i)&#123; int num=count(i); if (num&lt;=k)&#123; o[i]=1,o[i&lt;&lt;1]=1; f.a[i][i&lt;&lt;1]=1; &#125; if (num+1&lt;=k)&#123; o[i|(1&lt;&lt;m-1)]=1,o[i&lt;&lt;1|1]=1; f.a[i][i&lt;&lt;1|1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1|1]=1; &#125; &#125; f=f^n; for (int i=0;i&lt;=t;++i) if (o[i]) ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i]; cout&lt;&lt;ans; return 0;&#125;]]></content>
  </entry>
</search>
