<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 CF718C 【Sasha and Array】]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%A2%98%E8%A7%A3%20CF718C%20%E3%80%90Sasha%20and%20Array%E3%80%91%2F</url>
    <content type="text"><![CDATA[快速求$Fibonacci$第$n$项的方法是用矩阵乘法，即原始矩阵*$Fibonacci$矩阵^$(n-2)$,所以我们可以想到将$n$加上$k$相当于给$f[n]$乘上$Fibonacci$矩阵^$k$，所以我们可以想到线段树维护矩阵 对于第一个问题：由于矩阵具有分配律，即$a×b+a×c=a×(b+c)$，所以对于一段区间的矩阵可以相加维护。 对于第二个问题，显然将$[l,r]$的矩阵乘上转移矩阵的$x$次方即可。 用线段树维护即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define ll long long#define re register#define inf 0x3f3f3f3f#define ls(k) (k&lt;&lt;1)#define rs(k) (k&lt;&lt;1|1)#define mod 1000000007#define getchar() (p1==p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;using namespace std;struct node&#123; int a[3][3]; inline void init()&#123; a[1][1]=a[2][2]=1;a[1][2]=a[2][1]=0; &#125; inline void init0()&#123; a[1][1]=a[2][2]=a[1][2]=a[2][1]=0; &#125; inline void init1()&#123; a[1][1]=a[2][1]=a[1][2]=1;a[2][2]=0; &#125; friend node operator + (node aa,node bb)&#123; for(int i=1;i&lt;=2;i++) for(int j=1;j&lt;=1;j++)&#123; aa.a[i][j]=(aa.a[i][j]+bb.a[i][j]); if (aa.a[i][j]&gt;mod)aa.a[i][j]-=mod; &#125; return aa; &#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=1;i&lt;=2;++i) for (int k=1;k&lt;=2;++k) for (int j=1;j&lt;=2;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f[100005],p,jz[500005],tag[500005];inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;template &lt;class T&gt;inline void write(T x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; T y = 10, len = 1; while (y &lt;= x) &#123; y *= 10; ++len; &#125; while (len--) &#123; y /= 10; putchar(x / y + 48); x %= y; &#125;&#125;inline bool check(node tag)&#123; return tag.a[1][1]!=1||!tag.a[2][2]!=1||tag.a[1][2]!=0||tag.a[2][1]!=0;&#125;inline void pushup(int k)&#123; jz[k]=jz[ls(k)]+jz[rs(k)];&#125;void build(int k,int l,int r)&#123; tag[k].init(); if (l==r)&#123; jz[k]=f[l]; return; &#125; int mid=l+r&gt;&gt;1; build(ls(k),l,mid); build(rs(k),mid+1,r); pushup(k);&#125;inline void pushdown(int k)&#123; node sq=tag[k]; jz[ls(k)]=sq*jz[ls(k)]; tag[ls(k)]=tag[ls(k)]*sq; jz[rs(k)]=sq*jz[rs(k)]; tag[rs(k)]=tag[rs(k)]*sq; tag[k].init();&#125;void change(int k,int l,int r,int x,int y,node sq)&#123; if (x&lt;=l&amp;&amp;r&lt;=y)&#123; jz[k]=sq*jz[k]; tag[k]=tag[k]*sq; return; &#125; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid)change(ls(k),l,mid,x,y,sq); if (mid&lt;y) change(rs(k),mid+1,r,x,y,sq); pushup(k);&#125;node query(int k,int l,int r,int x,int y)&#123; if (x&lt;=l&amp;&amp;r&lt;=y) return jz[k]; int mid=l+r&gt;&gt;1; if (check(tag[k]))pushdown(k); if (x&lt;=mid&amp;&amp;mid&lt;y) return query(ls(k),l,mid,x,y)+query(rs(k),mid+1,r,x,y); else if (x&lt;=mid)return query(ls(k),l,mid,x,y); else return query(rs(k),mid+1,r,x,y);&#125;signed main()&#123; int n=read(),m=read(); p.init1(); node ttt; ttt.a[1][1]=ttt.a[2][1]=1; for (int i=1;i&lt;=n;++i)&#123; int x=read()-2; if (x==-1)f[i].a[1][1]=1,f[i].a[2][1]=0; else f[i]=(p^x)*ttt; &#125; build(1,1,n); while (m--)&#123; int opt=read(),x=read(),y=read(); if (opt==1)&#123; int d=read(); change(1,1,n,x,y,p^d); &#125;else&#123; node ans=query(1,1,n,x,y); write(ans.a[1][1]);puts(""); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1357花园]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%B4%9B%E8%B0%B7P1357%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$. 那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即$1$的个数不超过$k$）。($Floyd$矩阵) 所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。 那么怎么求得$f[i][j]$呢？ 枚举一个长度为$m-1$的状态，在它前面加$0/1$即是$i$，在它后面加$0/1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。 由于是个环，所以实质上有$n+m$个花圃，第$n+1$~$n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define int long long#define re register#define inf 0x3f3f3f3f#define mod 1000000007using namespace std;int n,m,k,t,o[39+39],ans;struct node&#123; int a[39+39][39+39]; inline void init()&#123; for (int i=0;i&lt;=t;++i) for (int j=0;j&lt;=t;++j) if (i==j) a[i][i]=1; else a[i][j]=0; &#125; inline void init0()&#123;memset(a,0,sizeof(a));&#125; friend node operator * (node a,node b)&#123; node c;c.init0(); for (int i=0;i&lt;=t;++i) for (int k=0;k&lt;=t;++k) for (int j=0;j&lt;=t;++j)&#123; c.a[i][j]+=1ll*a.a[i][k]*b.a[k][j]%mod; if (c.a[i][j]&gt;mod)c.a[i][j]-=mod; &#125; return c; &#125; friend node operator ^ (node a,int p)&#123; node res; res.init(); while(p)&#123; if(p&amp;1) res=res*a; p&gt;&gt;=1; a=a*a; &#125; return res; &#125;&#125;f;inline int read()&#123; int x=0,w=0;char ch=getchar(); while (!isdigit(ch))w|=ch=='-',ch=getchar(); while (isdigit(ch))x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0',ch=getchar(); return w?-x:x;&#125;inline int count(int x)&#123; int res=0; while (x)&#123; res+=x&amp;1; x&gt;&gt;=1; &#125; return res;&#125;signed main()&#123; n=read(),m=read(),k=read(); t=(1&lt;&lt;m)-1; for (int i=0;i&lt;=t&gt;&gt;1;++i)&#123; int num=count(i); if (num&lt;=k)&#123; o[i]=1,o[i&lt;&lt;1]=1; f.a[i][i&lt;&lt;1]=1; &#125; if (num+1&lt;=k)&#123; o[i|(1&lt;&lt;m-1)]=1,o[i&lt;&lt;1|1]=1; f.a[i][i&lt;&lt;1|1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1]=1; f.a[i|(1&lt;&lt;m-1)][i&lt;&lt;1|1]=1; &#125; &#125; f=f^n; for (int i=0;i&lt;=t;++i) if (o[i]) ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i]; cout&lt;&lt;ans; return 0;&#125;]]></content>
  </entry>
</search>
